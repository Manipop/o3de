/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#include <Atom/Features/ColorManagement/TransformColor.azsli>

// Simple reinhard tone mapping algorithm based on below paper.
// http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf
float3 TonemapReinhard(const float3 inputColor)
{
    return inputColor / (1.0 + inputColor);
}

// Extended Reinhard tone mapping algorithm with white point
// Luminance-based implementation that preserves hue while providing better highlight control
// https://64.github.io/tonemapping/#extended-reinhard-luminance-tone-map
float3 TonemapReinhardExtended(const float3 inputColor)
{
    // Rec. 709 luminance weights
    const float3 luminanceWeights = float3(0.2126f, 0.7152f, 0.0722f);
    
    // White point luminance - chosen for good balance in most scenes
    // Higher values compress highlights less, lower values compress more
    // This is something we could expose as a parameter in the future
    const float maxWhiteLuminance = 6.0f;
    
    // Calculate input luminance and ensure it's positive
    float inputLuminance = max(dot(inputColor, luminanceWeights), 1e-10f);
    
    // Apply extended Reinhard tonemapping to luminance
    // Formula: L_out = L_in * (1 + L_in / (maxWhite^2)) / (1 + L_in)
    float numerator = inputLuminance * (1.0f + (inputLuminance / (maxWhiteLuminance * maxWhiteLuminance)));
    float outputLuminance = numerator / (1.0f + inputLuminance);
    
    // Preserve chromaticity by scaling the original color
    // This maintains hue relationships while applying the tone curve
    return inputColor * (outputLuminance / inputLuminance);
}

// Originally written by Stephen Hill (@self_shadow)
// Input and output color are in AcesCG space
float3 TonemapAcesFitted(const float3 inputColor)
{
    // Apply RRT and ODT
    float a = 0.0245786f;
    float b = 0.000090537f;
    float c = 0.983729f;
    float d = 0.4329510f;
    float e = 0.238081f;
    return saturate((inputColor * (inputColor + a) - b) / (inputColor * (c * inputColor + d) + e));
}

// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
float3 TonemapAcesFilmic(const float3 inputColor)
{
    // Apply filmic curve. 
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return saturate((inputColor * (a * inputColor + b)) / (inputColor * (c * inputColor + d) + e));
}

// Applies the filmic curve from John Hable
float3 TonemapFilmic(const float3 inputColor)
{
    // See: https://github.com/dmnsgn/glsl-tone-map/blob/main/filmic.glsl
    float3 color = max(float3(0.0, 0.0, 0.0), inputColor - 0.004);
    return (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);
}

// AGX tone mapping implementation
// Reference: https://github.com/sobotka/AgX and https://github.com/google/filament
float3 TonemapAgxInternal(const float3 inputColor, const float3 slope, const float3 offset, const float3 power, const float saturation)
{
    // AGX Inset Matrix (input transform) - column major
    const float3x3 agxInsetMatrix = float3x3(
        0.856627153315983f, 0.0951212405381588f, 0.0482516061458583f,
        0.137318972929847f, 0.761241990602591f, 0.101439036467562f,
        0.11189821299995f, 0.0767994186031903f, 0.811302368396859f
    );
    
    // AGX Outset Matrix (output transform) - column major
    const float3x3 agxOutsetMatrix = float3x3(
        1.1271005818144368f, -0.11060664309660323f, -0.016493938717834573f,
        -0.1413297634984383f, 1.157823702216272f, -0.016493938717834257f,
        -0.14132976349843826f, -0.11060664309660294f, 1.2519364065950405f
    );
    
    // AGX constants
    const float agxMinEv = -12.47393f;
    const float agxMaxEv = 4.026069f;
    
    // Ensure no negative values
    float3 color = max(inputColor, 0.0f);
    
    // 1. AGX Transform
    // Input transform (inset)
    color = mul(agxInsetMatrix, color);
    
    // Avoid 0 or negative numbers for log2
    color = max(color, 1e-10f);
    
    // Log2 space encoding
    color = log2(color);
    color = (color - agxMinEv) / (agxMaxEv - agxMinEv);
    color = clamp(color, 0.0f, 1.0f);
    
    // Apply sigmoid function approximation (7th order polynomial from Filament)
    float3 x2 = color * color;
    float3 x4 = x2 * x2;
    float3 x6 = x4 * x2;
    color = - 17.86f    * x6 * color
            + 78.01f    * x6
            - 126.7f    * x4 * color
            + 92.06f    * x4
            - 28.72f    * x2 * color
            + 4.361f    * x2
            - 0.1718f   * color
            + 0.002857f;
    
    // 2. AGX Look (CDL operations)
    const float3 luminanceWeights = float3(0.2126f, 0.7152f, 0.0722f);
    float luma = dot(color, luminanceWeights);
    
    // ASC CDL
    color = pow(color * slope + offset, power);
    color = luma + saturation * (color - luma);
    
    // 3. AGX EOTF
    // Inverse input transform (outset)
    color = mul(agxOutsetMatrix, color);
    
    // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display
    // We linearize the output since O3DE expects linear sRGB
    color = pow(max(color, 0.0f), 2.2f);
    
    return color;
}

// Base AGX tonemapping
float3 TonemapAgx(const float3 inputColor)
{
    return TonemapAgxInternal(inputColor, float3(1.0f, 1.0f, 1.0f), float3(0.0f, 0.0f, 0.0f), float3(1.0f, 1.0f, 1.0f), 1.0f);
}

// AGX Golden - warmer, more cinematic look
float3 TonemapAgxGolden(const float3 inputColor)
{
    return TonemapAgxInternal(inputColor, float3(1.0f, 0.9f, 0.5f), float3(0.0f, 0.0f, 0.0f), float3(0.8f, 0.8f, 0.8f), 1.3f);
}

// AGX Punchy - higher contrast, more saturated
float3 TonemapAgxPunchy(const float3 inputColor)
{
    return TonemapAgxInternal(inputColor, float3(1.0f, 1.0f, 1.0f), float3(0.0f, 0.0f, 0.0f), float3(1.35f, 1.35f, 1.35f), 1.4f);
}

// AGX Warm - subtle warm cinematic look (less extreme than Golden)
float3 TonemapAgxWarm(const float3 inputColor)
{
    return TonemapAgxInternal(inputColor, float3(1.0f, 0.95f, 0.85f), float3(0.0f, 0.0f, 0.0f), float3(0.95f, 0.95f, 0.95f), 1.1f);
}

// Khronos PBR Neutral Tone Mapping
// Input color is non-negative and resides in the Linear Rec. 709 color space.
// Output color is also Linear Rec. 709, but in the [0, 1] range.
// https://github.com/KhronosGroup/ToneMapping
float3 TonemapPbrNeutral(const float3 inputColor)
{
    const float startCompression = 0.8f - 0.04f;
    const float desaturation = 0.15f;
    
    float3 color = inputColor;
    
    float x = min(color.r, min(color.g, color.b));
    float offset = x < 0.08f ? x - 6.25f * x * x : 0.04f;
    color -= offset;
    
    float peak = max(color.r, max(color.g, color.b));
    if (peak < startCompression) {
        return color;
    }
    
    const float d = 1.0f - startCompression;
    float newPeak = 1.0f - d * d / (peak + d - startCompression);
    color *= newPeak / peak;
    
    float g = 1.0f - 1.0f / (desaturation * (peak - newPeak) + 1.0f);
    return lerp(color, newPeak * float3(1.0f, 1.0f, 1.0f), g);
}

float3 ApplyManualExposure(float3 color, float exposure)
{
    // Apply Manual exposure
    return color * pow(2.0, exposure);
}
